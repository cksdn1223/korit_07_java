예외(Exception)란?
: 개발자가 예측할 수 있고, 그에 대한 대비를 할 수 있는 것들을 예외라고 정의
오류(Error)란?
: 개발자가 예측할 수 있지만 해결할 수 없거나 / 예측 불가능한 것을 오류라고 정의하는 편

다수의 예외의 경우에는 이미 개발자들이 정의를 해 놓았습니다.
예를 들어 List를 하나 정의했고, 거기에 element들을 집어넣었다고 가정하겠습니다.
그 경우에 List의 element들을 추출하기 위해서 반복문을 쓰게 될 텐데, i < strList.size()를 쓰지 않고 i < 30001 과 같은 방식으로 하드코딩을 했을 때에만 예외가 발생하겠죠.

그리고 향상된 for문을 사용한다면 예외를 볼 일이 전혀 없습니다.

왜 예외 처리를 하는가 ?
: 프로그램이 정상 종료됨을 보증하기 위하여

catch문이 복수로 나올 수 있다.
순서를 배치하는것이 매우 중요하다

사용자 정의 예외 처리 방식 역시
try / catch / finally 와 throws / throw가 추가되었을 뿐 method 의 정의 / 생성자 정의 / 객체 생성 방식이라는 여태까지 배워온 코드 작성 방법과 차이가 없다.

✔ 메서드에서 try-catch로 직접 예외를 처리한다면
→ throws 도, throw 도 사용하지 않아도 됩니다.

✔ throw만 있고 try-catch나 throws 없이 처리 안 하면
→ 컴파일 에러 (checked 예외의 경우)

✔ 실무에서는 대부분 throws로 예외를 넘기고,
→ 필요한 곳에서 한꺼번에 try-catch로 처리하는 구조를 많이 사용합니다.

# Lambda Expression(람다식)
- java 8에서 도입된 함수형 프로그래밍을 지원하기 위한 표현식

형식 :

```java
// (매개변수) -> {실행문}

// 기존의 익명 클래스 방식
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("Hello, Java");
        }
    };
    runnable.run();     // Hello, Java 가 출력됨
}
```
Interface Runnable 을 활용하여 임시적으로 run() 추상 메서드를 재정의하여 원하는 출력 결과를 도출하는 형태
너무 길다.
```java
// 람다식 적용 방식
public static void main(String[] args) {
    Runnable runnable = () -> System.out.println("Hello, Java");
    runnable.run();     // Hello, Java 가 출력됨.
}
```
람다식을 적용하면 짧다.

## 람다식의 등장 배경
- 람다식이 나오기 전에는 Java에서 함수형 프로그래밍을 하기 위한 익명 클래스를 주로 사용(첫번째 코드 블럭 예시)
- 하지만 이상의 방식은 예제에서 볼 수 있듯이 코드가 길어지고, 불필요한 반복이 많아지며, 가독성이 떨어지는 문제가 있었습니다.

```java
import java.util.Comparator;

public static void main(String[] args) {
    Comparator<Integer> comparator = new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o1.compareTo(o2);
        }
    };  // Comparator 인터페이스의 객체를 임의적으로 사용한 익명 클래스 예시
    
    Comparator<Integer> lambdaComparator = (o1, o2) -> o1.compareTo(o2);
}
```
## 람다식 장점
1. 코드 간결화 - 불필요한 코드 제거로(Integer 반복이 없다.), 가독성 향상
2. 표현력 향상 - 익명 클래스를 짧은 표현으로 대체
3. 지연 연산 - Stream API와 함께 사용시 지연 연산을 통해 성능 최적화

## 람다식 단점
1. 디버깅 어려움 - 람다식 내부에서 발생하는 오류의 디버깅이 어렵다.
2. 재사용성 낮음 - 익명 클래스에 '비해' 재사용이 어려움.
3. 복잡한 로직 표현에 부적합 - 단순 로직의 경우 람다식으로 사용, 아닌 경우는 익명 클래스 사용

## 람다식 문법
람다식 구조는 크게 3가지로 나뉩니다.
1. 매개변수 목록
2. 화살표(->) : 그래서 Js에서는 arrow expression이라고 표현
3. 구현부/실행문

```java
public static void main(String[] args) {
    // 1. 매개변수와 실행문이 하나일 때(중괄호 생략 가능)
    (int x, int y) -> x + y     // return 생략
    // 2. 매개변수가 하나일 때(소괄호 생략 가능)
    str -> System.out.println(str);
    // 3. 실행문이 여러 줄일 때(중괄호 필수)
    (x, y) -> {
        int sum = x + y;
        return sum;
    }
}
```

## 함수형 인터페이스(Functional Interface)
- 람다식은 단일 메서드만 가지는 인터페이스(얘를 함수형 인터페이스라고 합니다.)를 구현하는 형태로 사용됩니다. `@FunctionalInterface` 애너테이션을 사용하면 컴파일 시에 단이일 메서드인지 체크합니다.
- 그래서 '사용자 정의 함수형 인터페이스'를 작성할 때 클래스 레벨에 `@FunctionalInterface`를 명시해줍니다.

이유를 명확하게 알 필요가 있습니다.
인터페이스에 있는 메서드는 전부 '추상 메서드' 입니다. -> 얘를 implement 받게 되면 추상 메서드들을 전부 다 '강제로 구현'해야만 합니다.

하지만 아까 말한것처럼 여러 유형을 하나의 객체에 강제 구현하게 될 경우 필요한것 외에 나머지도 정의 해야한다는 문제점이 발생하기 때문에 각 유형 당 하나의 인터페이스/추상메서드만 존재하게 됐습니다.

```java
@FunctionalInterface    // 메서드 하나 초과면 오류 발생
interface MyFunction {
    void start();   // 인터페이스 정의했고, 추상메서드가 하나 있습니다.
}

public static void main(String[] args) {
    MyFunction myFunction = () -> System.out.println("정의한 함수를 실행합니다.");
    // 매개변수가 아예 없는 경우는 ()로 표시 합니다. 매개변수가 하나면 소괄호 생략이었습니다.
    myFunction.start();
}
```
## Java에서 제공하는 주요 '함수형 인터페이스'
1. Runnable - void run();
2. Consumer - void accept(T t);
3. Supplier - T get();
4. Function<T, R> - R apply(T t);
5. Predicate - boolean Test(T t); - 얘는 return 타입이 boolean으로 고정

### 함수형 인터페이스 별 상세
1. Runnable
- 매개변수도 없고, 반환값도 없는 단순 실행을 위한 인터페이스
- 사용처 : 스레드 실행 시, 비동기 작업 실행시
2. Consumer
- 값을 매개변수로 받아서 사용하고, 아무 것도 반환하지 않는 인터페이스, 데이터를 '소비' 하는 역할
- 사용처 : 데이터 처리, 로깅, 이벤트 핸들러
3. Supplier
- 매개변수 없이 값을 반환하는 인터페이스, 단순히 값을 '공급' 하는 역할
- 사용처 : 객체 생성, 지연 로딩
4. Function<T, R>
- '하나의 매개변수'를 받아서, 연산을 수행한 후 결과를 리턴함.
  -  T 는 입력 타입, R은 리턴 타입을 명시함.
- 사용처 : 데이터 변환, 매핑 처리, 컬렉션 조작
5. Predicate
- '하나의 매개변수'를 받아서 특정 조건을 검사한 뒤 true / false 를 반환
- 사용처 : 필터링, 조건 검사, 유효성 검사
  - 특히 Predicate의 경우 true / false 반환값을 가지고 조건문을 돌릴 때 많이 사용됩니다.
6. 함수형 인터페이스 조합
- java 8에서는 함수형 인터페이스끼리의 조합이 가능합니다.
```java
import java.util.function.Predicate;

public static void main(String[] args) {
    //메서드1
    Predicate<String> startsWithA = str -> str.startsWith("A");
    // 메서드2
    Predicate<String> endsWithX = str -> str.endsWith("X");
    
    // and() 로 두 조건 결합
    Predicate<String> startsWithAAndEndsWithX = startsWithA.and(endsWithX);

    System.out.println(startsWithAAndEndsWithX.Test("Alex"));
}
```



# 시험 관련 안내
09:00 안내시작 > 09:10 ~ 17:50
객체지향 프로그래밍 언어
1. 프로그래밍 언어 활용
2. 프로그래밍 언어 응용

## 프로그래밍 언어 활용
20문제 서답형

.md 파일 상에서 명시적으로 정리되지 않은 부분 있음
구글에서 검색하는 것 가능.
Github 확인 등 전부 가능
ctrl + shift + f 전체 검색

- 특정 문제가 md 파일에 없다는것을 확신하신다면 구글에서 검색

특정 메서드 이름을 적으시오.
특정 자료형을 적으시오.
키워드를 적으시오 etc..

## 프로그래밍 언어 응용
JSON        -20
Singleton   -20
Builder     -30
Collection  -30

저장만 누르면 안되고 제출까지 하셔야 합니다.
제출하면 수정이 안됨.
60점 미만은 재시험 대상자
1과목 / 2 과목 둘다 60 이상


