# Getter / Setter
## Getter / Setter 의 필요성
1. 문제상황
   - 클래스를 하나 만든다고 가정합니다. 예를 들어 , Person 클래스를 생성하면서 이름, 나이 등의 정보를
   저장하기 위해 필드를 선언합니다.
```java
public class Person{
    String name;
    int age;
}
public class PersonMain{
    public static void main(String[] args){
        //Person 객체 생성
        Person person1 = new Person();
        person1.name = "김일";   
        // 객체명.속성명 = 데이터;  -> 객체에 값을 대입하는 방법
        person1.age = -10;

        System.out.println(person1.name);   // 결과값 : 김일
        System.out.println(person1.age);    // 결과값 : -10
    }
}
```
이상의 코드를 확인했을 때, 나이에 정상적이지 않은 값이 대입되어있습니다. 이처럼 외부(다른 클래스)에서
직접 속성값을 대입하게 될 때, 이상한 값이 들어가더라도 통제할 수 있는 방법이 없다는 문제가 있습니다.

-> 이상을 해결하기 위한 방법이 getter / setter 개념입니다.

## Getter / Setter 란?
1. Setter
    - 데이터를 '설정' 하는 역할의 'method' 클래스 외부에서 필드를 직접 수정하지 못하도록 막고,
    특정 메서드를 경유하여 값을 전달 받아 '초기화 및 수정' 을 하도록 함.
2. Getter
    - 데이터를 '조회' 하는 역할의 'method' 클래스 외부에서 필드를 직접 읽지 못하도록 막고,
    특정 메서드를 경유하여 안전하게 값을 '반환(return)' 하도록 함.
3. 장점
    1. 데이터보호
       - 변수가 private 접근 제어자를 사용하여 외부에서 직접 접근하지 못하게 함으로써 데이터를
       보호할 수 있음.
    2. 데이터의 유효성 검증
        - Setter 메서드에서 입력된 데이터가 적합한지 확인하고, 잘못된 값을 거절할 수 있음
    3. 캡슐화(Encapsulation)
        - 데이터를 숨기고 필요한 경우에만 제한적으로 접근할 수 있도록 하여 클래스 내부 구현을
        외부로 노출하지 않음.
    4. 유연성 증가
        - 나중에 요구 사항이 바뀌어 데이터를 설정하거나 조회하는 방법이 변경되더라도 클래스(Main말고)
        내부의 메서드만 수정하면 되므로 유지 보수가 쉬워짐.
## Setter / Getter 의 구조
### Setter

```java
접근지정자 void set속성명1(자료형 변수명) {
    this.속성명1 = 변수명;
}

public void setName(String name){
    this.name = name;
}
```
### Getter
```java
접근지정자 자료형 get속성명1() {
    return 속성명1;
}
public int getAge() {
    return age;
}

```
### Setter를 기준으로 데이터 유효성 검증 예시
```java
public class Person{
    // 필드 선언
    int age;
    public void setAge(int birth){
        if(birth < 0 || birth > 200) {
            System.out.println("불가능한 나이 입력입니다.");
            return;     // method 에서 return; 은 method 즉시 종료 키워드 입니다.
                        // 즉 이 이하로는 아예 실행되지 않습니다.
        }
        System.out.println("변경 전 나이 : " + age);
        this.age = birth;
        System.out.println("변경 후 나이 : " + age);
    }
}
```

# 접근 지정자(Access Modifier)
## 정의
- 클래스, 필드, 변수, 메서드의 접근 범위를 제어하는 키워드
- 사용 이유
  - 정보 은닉(캡슐화 : Encapsulation)을 실현하고, 코드의 보안성과 유지보수성을 위해
## 접근 지정자의 종류
1. public - 모든 클래스에서 접근 가능
    - 완전히 공개된 상태
    - 누구든지 사용 가능
    - 보통 라이브러리나 API의 공개된 기능에 사용됨.
```java
public class Car {
    public String model = "셀토스";
    public void drive() {
        System.out.println("자동차를 운전합니다.");
    }
}
```
이상의 코드는 다른 어떤 클래스를 생성하더라도 경로만 정확하다면 Car car1 = new Car(); 로 객체를
생성할 수 있고 (class가 public이니까), System.out.println(car1.model); 이라고 했을 때
'셀토스' 라는 String 데이터가 콘솔에 찍힐겁니다 (field가 public이니까).
마지막으로 car1.drive(); 를 호출해도 콘솔에 "자동차를 운전합니다." 라는 텍스트가 콘솔에 나올겁니다
(method가 public이니까).

2. protected - 같은 패키지 내의 클래스 및 이 클래스를 상속받은 자식 클래스에서 접근 가능
    - default와 같지만 자식클래스에서 상속받아서 사용 가능
```java
package vehicle;

public class Car {
    protected String brand = "기아";
}
//같은 패키지의 다른 클래스
package vehicle;
import vehicle.Car;
public class MyCar extends Car {   
    public void showBrand() {
        System.out.println(brand);
    }
}
```
Car 클래스의 protected 필드인 brand 를 동일한 패키지의 MyCar 클래스에서 '직접 조회' 했습니다

3. default - 접근 지정자를 명시하지 않으면 default 로 간주되며, 같은 패키지 내의 클래스에서
             접근 가능
    - 같은 패키지 안에서는 접근 가능, 다른 패키지에서는 불가능
```java
class Car {
    String color = "red";
}
```
이상의 경우, class 레벨도 default / field 레벨도 default라고 볼 수 있습니다.

4. private - 같은 클래스 내에서만 접근 가능
    - 가장 제한적인 접근 지정자
    - 클래스 외부에서는 전혀 접근할 수 없음
    - 데이터 보호 목적으로 사용
```java
public class Car {
    private String engine = "V6";
    public void showEngine() {
        System.out.println("엔진 정보 : " + engine);
    }
}
//별개의 클래스
public class CarMain {
    public static void main(String[] args) {
        Car car1 = new Car();
        System.out.println(car1.engine);    // 컴파일링 오류 : 필드 자체는 private
        car1.showEngine();  // 엔진 정보 : V6 라고 출력됨 -> method는 public이기 때문
    }
}
```
Car를 기준으로 field는 private / 일부 정보만 공개하게 되는 method는 public이기 때문에
CarMain에서 객체를 생성하는 것 가능(class level - public) / 엔진 정보를 직접 조회하는 것
(car1.engine)은 불가능 field는 private이니까 하지만 method를 경유하여 조회하는 것은
가능 (car1.showEngine()) - method 는 public이니까.

## 실무적인 관점에서의 접근 지정자 선택
1. 필드는 원칙적으로 -> private
2. 메서드는 외부 공개 필요시 -> public
3. 상속 대상 메서드는 -> protected
4. 패키지 내부에서만 쓰이는 도우미 클래스 -> (default)
### 항상 그런 것은 아니지만 염두해두면 좋은 부분
1. 필드는 웬만하면 private 로 지정하고, 접근은 getter / setter 를 통하자(자동완성이 public인 이유)
2. 인터페이스나 라이브러리는 public을 최소화할 것. 이미 공개된 API는 되돌리기 어려움
    - 다른 회사가 내가 만든 class를 쓰고 있는데 멀쩡하게 public으로 되어있던게 default로 바뀌게 되면
      그 회사는 더이상 제가 만든 class를 사용하지 못하게 될거고, 기존 로직을 다 갈아엎어야 할 겁니다.